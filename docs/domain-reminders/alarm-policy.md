# 알람 시스템 정책

## 개요

이 문서는 OTU의 알람 시스템 정책을 정의합니다. 알람 간격, 시간 충돌 방지, 수면시간 회피 등의 핵심 규칙을 포함합니다.

## 알람 간격 정책 (승수 시스템)

### 기본 원칙

알람은 점진적으로 간격이 증가하여 사용자에게 과도한 알림을 방지합니다.

### 간격 규칙

```
sent_count = 1: next_alarm_time = null (사용자가 알람을 켰을 때 supabasejs를 통해서 클라이언트 측에서 직접 데이터를 변경함. )
sent_count = 2: 1일 후 정각
sent_count = 3: 2일 후 정각
sent_count = 4: 4일 후 정각
sent_count = 5: 8일 후 정각
...
```

> **참고**
> • 클라이언트가 알람 스위치를 켜면 `sent_count = 1`, `next_alarm_time = null` 레코드만 생성합니다.
> • 크론 작업이 이 레코드를 감지하면 `sent_count = 2`, `next_alarm_time = 1일 후 정각`으로 갱신하고, 푸시 알림을 발송합니다.

### 계산 공식

- **첫 번째 백엔드 처리** (`sent_count = 1 → 2`): 현재 시간 기준 1일 후 정각
- **이후** (`sent_count ≥ 2`): 현재 시간 + 2^(sent_count-2) 일, 결과는 항상 정각(분·초 0)

## 시간 충돌 방지 정책

### 기본 원칙

각 사용자별로 동일한 시간대에는 최대 1개의 알람만 허용됩니다.

### 충돌 감지 시점

2. **알람 발송 및 갱신 시**: next_alarm_time 이 현재 시간 보다 과거인 행에 대해서 푸시 알림 API로 알람 발송 후에 새로운 next_alarm_time을 계산하여 업데이트 합니다.

### 충돌 해결 알고리즘

```
1. 계산된 정각 시간에 해당 사용자의 기존 알람 존재 확인
2. 충돌 발견 시 0~23시간 범위 내 랜덤 오프셋(정각 유지)을 적용해 새 시간 계산
3. 수면시간(22:00~07:00, 사용자 TZ)이면 다음날 07:00로 이동
4. 최대 50회 시도 후에도 해결되지 않으면 next_alarm_time을 1주일 뒤로 돌리고 종료. 이 경우 사용자에게 알람을 발송하지 않음.
```

### 예시

```
사용자A 상황:
- 기존: 오후 3시 알람 있음
- 신규: 오후 3시로 계산됨
- 결과: 자동으로 오후 4시로 조정
```

## 수면시간 회피 정책

### 수면시간 정의

- **시작**: 22:00 (저녁 10시)
- **종료**: 07:00 (아침 7시)

### 회피 규칙

1. 계산된 알람 시간이 수면시간에 해당하면 다음날 07:00로 조정

### 경계값 처리

```
21:59 → 22:00 (수면시간 직전, 그대로 유지)
22:00 → 다음날 07:00 (수면시간 시작, 조정)
06:59 → 07:00 (수면시간 끝, 조정)
07:00 → 07:00 (수면시간 종료, 그대로 유지)
```

## 시간대 처리 정책

사용자의 `userinfo.timezone` 정보를 기반으로 수면시간 회피 계산을 수행합니다.
해당 값이 없는 경우 기본값으로 `Asia/Seoul`을 사용합니다.

## 발송 제한 정책

현재는 발송 횟수를 제한하지 않습니다. 알람은 무제한으로 갱신되며, `sent_count` 는 계속 증가합니다.
